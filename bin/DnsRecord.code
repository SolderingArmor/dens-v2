.macro constructor
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7_with_init_storage$
}
;; constructor protection
GETGLOB 6
THROWIF 51
PUSHINT 1
SETGLOB 6
;; end constructor protection
; Decode input parameters
; Decode ownerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode forceFeeReturnToOwner
LDIQ 1
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDI 1
}
IFNOT
ENDS
;; param: ownerAddress
;; param: forceFeeReturnToOwner
; constructor DnsRecord
;; push identifier ownerAddress
PUSH S1
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
THROWIF 212
;; get member wid
MYADDR
PARSEMSGADDR
INDEX 2
THROWIF 103
ACCEPT
;; push identifier _domainName
GETGLOB 10
CALLREF {
	CALL $_validateDomainName_internal_macro$
}
; expValue
; end expValue
; colValue
; end colValue
;; push identifier _nameIsValid
DUP
SETGLOB 11
THROWIFNOT 200
;; push identifier _domainName
GETGLOB 10
CALLREF {
	CALL $_parseDomainName_internal_macro$
}
;; decl: segments
;; decl: parentName
;; get member length
;; push identifier segments
PUSH S1
INDEX 0
;; uint8
UFITS 8
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
SWAP
; colValue
SETINDEX 1
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
;; push identifier _domainName
GETGLOB 10
; colValue
SETINDEX 2
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
;; push identifier parentName
PUSH S1
; colValue
SETINDEX 3
SETGLOB 13
; end colValue
;; push identifier parentName
DUP
CALLREF {
	CALL $calculateDomainAddress_internal_macro$
}
; expValue
;; fetch _whoisInfo
; end expValue
; colValue
; end colValue
DROP
GETGLOB 13
SWAP
SETINDEX 4
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
;; get member DENY
PUSHINT 3
; colValue
SETINDEX 9
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
;; push identifier now
NOW
; colValue
SETINDEX 12
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
PUSHINT 0
; colValue
SETINDEX 7
SETGLOB 13
; end colValue
;; if
;; get member sender
GETGLOB 9
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
PUSHCONT {
	CALLREF {
		CALL $_reserve_internal_macro$
	}
	;; push identifier ownerAddress
	PUSH S3
	CALLREF {
		CALL $_claimExpired_internal_macro$
	}
	;; transfer()
	;; push identifier ownerAddress
	PUSH S3
	NEWC
	STSLICECONST x42_
	STSLICE
	PUSHINT 111
	STZEROES
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
PUSHCONT {
	;; if
	;; get member value
	CALLREF {
		CALL $message_balance_macro$
	}
	GTINT 0
	PUSHCONT {
		;; push identifier ownerAddress
		;; push identifier forceFeeReturnToOwner
		OVER2
		CALLREF {
			CALL $claimExpired_internal_macro$
		}
	}
	IF
	;; end if
}
IFELSE
;; end if
; end constructor DnsRecord
BLKDROP 4
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro calculateDomainAddress
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode domainName
LDREF
ENDS
;; param: domainName
CALLREF {
	CALL $calculateDomainAddress_internal_macro$
}
;; emitting 2 value(s)
PUSH S2
EQINT -1
PUSHCONT {
	PUSH S4
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHSLICE x0000000000000000000000003b4dccc9e_
	STSLICER
	PUSH S2
	STSLICER
	PUSH S1
	STREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP2
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	calculateDomainAddress_internal
.type	calculateDomainAddress_internal, @function
CALL $calculateDomainAddress_internal_macro$

.macro calculateDomainAddress_internal_macro
;; param: domainName
; function calculateDomainAddress
NEWDICT
PUSHINT 0
NEWC
STU 256
PUSHINT 0
ROT
PUSHINT 64
DICTUSETB
;; push identifier domainName
PUSH S1
PUSHINT 1
ROT
PUSHINT 64
DICTUSETREF
;; push identifier _domainCode
GETGLOB 12
PUSHINT 2
ROT
PUSHINT 64
DICTUSETREF
NEWC
STDICT
ENDC
;; push identifier _domainCode
GETGLOB 12
NEWC
STSLICECONST x2_
STOPTREF
STOPTREF
STZERO
ENDC
;; decl: stateInit
;; return
;; push identifier stateInit
DUP
HASHCU
NEWC
STSLICECONST x801_
STU 256
ENDC
CTOS
;; push identifier stateInit
PUSH S1
; end function calculateDomainAddress
BLKDROP2 2, 2

.globl	_claimExpired_internal
.type	_claimExpired_internal, @function
CALL $_claimExpired_internal_macro$

.macro _claimExpired_internal_macro
;; param: newOwnerAddress
; function _claimExpired
;; if
;; get member segmentsCount
;; push identifier _whoisInfo
GETGLOB 13
INDEX 1
EQINT 1
PUSHCONT {
	;; get member APPROVED
	PUSHINT 1
	;; push identifier newOwnerAddress
	PUSH S1
	CALLREF {
		CALL $_callbackOnRegistrationRequest_internal_macro$
	}
}
IF
;; end if
; end function _claimExpired
DROP

.macro claimExpired
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode newOwnerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode forceFeeReturnToOwner
LDIQ 1
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDI 1
}
IFNOT
ENDS
;; param: newOwnerAddress
;; param: forceFeeReturnToOwner
CALLREF {
	CALL $claimExpired_internal_macro$
}
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	claimExpired_internal
.type	claimExpired_internal, @function
CALL $claimExpired_internal_macro$

.macro claimExpired_internal_macro
;; param: newOwnerAddress
;; param: forceFeeReturnToOwner
; modifier Expired
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIFNOT 202
; modifier NameIsValid
;; push identifier _nameIsValid
GETGLOB 11
THROWIFNOT 200
; function claimExpired
GETGLOB 5
DUP
ISNULL
PUSHCONT {
	DROP
	PUSHINT 0
}
IF
EQINT 0
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; get member value
		CALLREF {
			CALL $message_balance_macro$
		}
		GTINT 0
	}
	IF
}
IF
THROWIFNOT 102
CALLREF {
	CALL $_reserve_internal_macro$
}
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
CALLREF {
	CALL $_changeOwner_internal_macro$
}
;; push identifier newOwnerAddress
PUSH S1
CALLREF {
	CALL $_claimExpired_internal_macro$
}
;; if
;; get member segmentsCount
;; push identifier _whoisInfo
GETGLOB 13
INDEX 1
GTINT 1
PUSHCONT {
	;; push identifier newOwnerAddress
	;; push identifier forceFeeReturnToOwner
	DUP2
	CALLREF {
		CALL $_sendRegistrationRequest_internal_macro$
	}
}
PUSHCONT {
	;; transfer()
	;; push identifier forceFeeReturnToOwner
	DUP
	PUSHCONT {
		;; push identifier newOwnerAddress
		PUSH S1
	}
	PUSHCONT {
		;; get member sender
		GETGLOB 9
	}
	IFELSE
	NEWC
	STSLICECONST x42_
	STSLICE
	PUSHINT 111
	STZEROES
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
IFELSE
;; end if
; end function claimExpired
; end modifier NameIsValid
; end modifier Expired
DROP2

.globl	_sendRegistrationRequest_internal
.type	_sendRegistrationRequest_internal, @function
CALL $_sendRegistrationRequest_internal_macro$

.macro _sendRegistrationRequest_internal_macro
;; param: newOwnerAddress
;; param: forceFeeReturnToOwner
; function _sendRegistrationRequest
;; Remote call IDnsRecord.receiveRegistrationRequest
;; get member parentDomainAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 4
NEWC
STSLICECONST x62_
STSLICE
PUSHINT 1
STUR 111
NEWC
STSLICECONST x3234a5b9
STSLICECONST x01e0b744
;; domainName
;; push identifier _domainName
GETGLOB 10
STREFR
;; ownerAddress
;; push identifier newOwnerAddress
PUSH S3
STSLICER
;; payerAddress
;; push identifier forceFeeReturnToOwner
PUSH S2
PUSHCONT {
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
}
PUSHCONT {
	;; get member sender
	GETGLOB 9
}
IFELSE
STSLICER
STBREFR
ENDC
PUSHINT 128
SENDRAWMSG
; end function _sendRegistrationRequest
DROP2

.macro receiveRegistrationRequest
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
; Decode domainName
LDREF
; Decode ownerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode payerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: domainName
;; param: ownerAddress
;; param: payerAddress
; function receiveRegistrationRequest
;; push identifier domainName
PUSH S2
PUSHINT 4294967295
CDATASIZE
DROP
NIP
RSHIFT 3
;; >=
PUSHINT 2
GEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier domainName
	PUSH S2
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	;; <=
	;; push identifier MAX_DOMAIN_LENGTH
	;; *
	PUSHINT 124
	UFITS 32
	;; +
	;; push identifier MAX_SEPARATORS_NUMBER
	PUSHINT 4
	;; -
	DEC
	UFITS 32
	ADD
	UFITS 32
	LEQ
}
IF
THROWIFNOT 200
;; push identifier domainName
PUSH S2
CALLREF {
	CALL $calculateDomainAddress_internal_macro$
}
;; decl: addr
;; push identifier addr
PUSH S1
;; get member sender
GETGLOB 9
SDEQ
THROWIFNOT 210
;; push identifier domainName
PUSH S4
CALLREF {
	CALL $_parseDomainName_internal_macro$
}
;; decl: parentName
;; push identifier parentName
DUP
HASHCU
;; get member domainName
;; push identifier _whoisInfo
GETGLOB 13
INDEX 2
HASHCU
EQUAL
THROWIFNOT 209
CALLREF {
	CALL $_reserve_internal_macro$
}
PUSHINT 0
;; decl: result
;; if
;; get member registrationType
;; push identifier _whoisInfo
GETGLOB 13
INDEX 9
;; ==
;; get member FFA
EQINT 0
PUSHCONT {
	; expValue
	; end expValue
	;; get member APPROVED
	; colValue
	DROP
	PUSHINT 1
	; end colValue
}
PUSHCONT {
	;; if
	;; get member registrationType
	;; push identifier _whoisInfo
	GETGLOB 13
	INDEX 9
	;; ==
	;; get member DENY
	EQINT 3
	PUSHCONT {
		; expValue
		; end expValue
		;; get member DENIED
		; colValue
		DROP
		PUSHINT 2
		; end colValue
	}
	PUSHCONT {
		;; if
		;; get member registrationType
		;; push identifier _whoisInfo
		GETGLOB 13
		INDEX 9
		;; ==
		;; get member MONEY
		EQINT 1
		PUSHCONT {
			PUSHINT 300000
			PUSHINT 0
			CALLREF {
				CALL $__gasToTon_macro$
			}
			;; decl: minimumFee
			;; if
			;; get member value
			CALLREF {
				CALL $message_balance_macro$
			}
			;; >=
			;; get member registrationPrice
			;; push identifier _whoisInfo
			GETGLOB 13
			INDEX 8
			;; +
			;; push identifier minimumFee
			PUSH S2
			ADD
			UFITS 128
			GEQ
			PUSHCONT {
				;; transfer()
				;; get member registrationPrice
				;; push identifier _whoisInfo
				GETGLOB 13
				INDEX 8
				;; get member ownerAddress
				;; push identifier _whoisInfo
				GETGLOB 13
				INDEX 5
				NEWC
				STSLICECONST x42_
				STSLICE
				SWAP
				STGRAMS
				PUSHINT 107
				STZEROES
				ENDC
				PUSHINT 1
				SENDRAWMSG
				;; get member registrationPrice
				;; push identifier _whoisInfo
				GETGLOB 13
				INDEX 8
				; expValue
				;; fetch _whoisInfo
				GETGLOB 13
				DUP
				PUSHINT 16
				INDEXVAR
				; end expValue
				ROT
				ADD
				UFITS 128
				; colValue
				PUSHINT 16
				SETINDEXVAR
				SETGLOB 13
				; end colValue
				; expValue
				; end expValue
				;; get member APPROVED
				PUSHINT 1
				; colValue
				POP S2
				; end colValue
			}
			PUSHCONT {
				; expValue
				; end expValue
				;; get member NOT_ENOUGH_MONEY
				PUSHINT 3
				; colValue
				POP S2
				; end colValue
			}
			IFELSE
			;; end if
			DROP
		}
		PUSHCONT {
			;; if
			;; get member registrationType
			;; push identifier _whoisInfo
			GETGLOB 13
			INDEX 9
			;; ==
			;; get member OWNER
			EQINT 2
			PUSHCONT {
				;; push identifier ownerAddress
				PUSH S6
				;; get member ownerAddress
				;; push identifier _whoisInfo
				GETGLOB 13
				INDEX 5
				SDEQ
				;; decl: ownerCalled
				; expValue
				; end expValue
				;; push identifier ownerCalled
				DUP
				PUSHCONT {
					;; get member APPROVED
					PUSHINT 1
				}
				PUSHCONT {
					;; get member DENIED
					PUSHINT 2
				}
				IFELSE
				; colValue
				POP S2
				; end colValue
				DROP
			}
			IF
			;; end if
		}
		IFELSE
		;; end if
	}
	IFELSE
	;; end if
}
IFELSE
;; end if
;; if
;; push identifier result
DUP
;; ==
;; get member APPROVED
EQINT 1
PUSHCONT {
	PUSHINT 1
	; expValue
	;; fetch _whoisInfo
	GETGLOB 13
	DUP
	INDEX 14
	; end expValue
	ROT
	ADD
	UFITS 128
	; colValue
	SETINDEX 14
	SETGLOB 13
	; end colValue
	;; emit newSubdomainRegistered
	PUSHSLICE xc000000000000000000000000027575450
	NEWC
	STSLICE
	;; dt
	;; push identifier now
	NOW
	STUR 32
	;; domainName
	;; push identifier domainName
	PUSH S8
	STREFR
	;; price
	;; get member registrationPrice
	;; push identifier _whoisInfo
	GETGLOB 13
	INDEX 8
	STUR 128
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	;; if
	;; push identifier result
	DUP
	;; ==
	;; get member DENIED
	EQINT 2
	PUSHCONT {
		PUSHINT 1
		; expValue
		;; fetch _whoisInfo
		GETGLOB 13
		DUP
		INDEX 15
		; end expValue
		ROT
		ADD
		UFITS 128
		; colValue
		SETINDEX 15
		SETGLOB 13
		; end colValue
	}
	IF
	;; end if
}
IFELSE
;; end if
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
PUSHINT 128
SETINDEXQ 4
SETGLOB 4
;; push identifier result
DUP
;; push identifier ownerAddress
;; push identifier payerAddress
BLKPUSH 2, 7
; end function receiveRegistrationRequest
BLKDROP2 8, 3
;; emitting 3 value(s)
PUSH S3
EQINT -1
PUSHCONT {
	PUSH S5
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 1
	STUR 98
	NEWC
	STSLICECONST xb234a5b9
	PUSH S4
	STUR 8
	PUSH S3
	STSLICER
	PUSH S2
	STSLICER
	STBREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 1
	STUR 106
	NEWC
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S4
	STUR 8
	PUSH S3
	STSLICER
	PUSH S2
	STSLICER
	STBREFR
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
BLKDROP 3
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	_callbackOnRegistrationRequest_internal
.type	_callbackOnRegistrationRequest_internal, @function
CALL $_callbackOnRegistrationRequest_internal_macro$

.macro _callbackOnRegistrationRequest_internal_macro
;; param: result
;; param: ownerAddress
; function _callbackOnRegistrationRequest
;; emit registrationResult
PUSHSLICE xc000000000000000000000000026ff5075
NEWC
STSLICE
;; dt
;; push identifier now
NOW
STUR 32
;; result
;; push identifier result
PUSH S2
STUR 8
;; ownerAddress
;; push identifier ownerAddress
PUSH S1
STSLICER
ENDC
PUSHINT 0
SENDRAWMSG
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
;; push identifier result
PUSH S2
; colValue
SETINDEX 10
SETGLOB 13
; end colValue
;; if
;; push identifier result
PUSH S1
;; ==
;; get member APPROVED
EQINT 1
PUSHCONT {
	; expValue
	;; fetch _whoisInfo
	GETGLOB 13
	; end expValue
	;; push identifier ownerAddress
	PUSH S1
	; colValue
	SETINDEX 5
	; end colValue
	; expValue
	;; fetch _whoisInfo
	DUP
	SETGLOB 13
	; end expValue
	;; push identifier now
	NOW
	;; +
	;; push identifier ninetyDays
	;; *
	PUSHINT 7776000
	UFITS 32
	ADD
	UFITS 32
	; colValue
	SETINDEX 7
	SETGLOB 13
	; end colValue
	PUSHINT 1
	; expValue
	;; fetch _whoisInfo
	GETGLOB 13
	DUP
	INDEX 13
	; end expValue
	ROT
	ADD
	UFITS 128
	; colValue
	SETINDEX 13
	SETGLOB 13
	; end colValue
}
IF
;; end if
; end function _callbackOnRegistrationRequest
DROP2

.macro callbackOnRegistrationRequest
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode result
LDU 8
; Decode ownerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
; Decode payerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: result
;; param: ownerAddress
;; param: payerAddress
; modifier onlyRoot
;; get member parentDomainAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 4
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 101
; function callbackOnRegistrationRequest
CALLREF {
	CALL $_reserve_internal_macro$
}
;; if
CALLREF {
	CALL $isExpired_internal_macro$
}
PUSHCONT {
	;; push identifier result
	;; push identifier ownerAddress
	BLKPUSH 2, 2
	CALLREF {
		CALL $_callbackOnRegistrationRequest_internal_macro$
	}
}
IF
;; end if
;; if
;; push identifier payerAddress
DUP
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
NOT
PUSHCONT {
	;; transfer()
	;; push identifier payerAddress
	DUP
	NEWC
	STSLICECONST x42_
	STSLICE
	PUSHINT 111
	STZEROES
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
PUSHCONT {
	;; transfer()
	;; push identifier ownerAddress
	PUSH S1
	NEWC
	STSLICECONST x42_
	STSLICE
	PUSHINT 111
	STZEROES
	ENDC
	PUSHINT 128
	SENDRAWMSG
}
IFELSE
;; end if
; end function callbackOnRegistrationRequest
; end modifier onlyRoot
BLKDROP 3
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getDomainCode
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; function getDomainCode
;; return
;; push identifier _domainCode
GETGLOB 12
; end function getDomainCode
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHSLICE x000000000000000000000000210f1f72a_
	STSLICER
	PUSH S1
	STREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro canProlongate
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
CALLREF {
	CALL $canProlongate_internal_macro$
}
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHSLICE x0000000000000000000000003127469ca_
	STSLICER
	PUSH S1
	STIR 1
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	canProlongate_internal
.type	canProlongate_internal, @function
CALL $canProlongate_internal_macro$

.macro canProlongate_internal_macro
; function canProlongate
;; return
;; push identifier now
NOW
;; <=
;; get member dtExpires
;; push identifier _whoisInfo
GETGLOB 13
INDEX 7
LEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier now
	NOW
	;; >=
	;; get member dtExpires
	;; push identifier _whoisInfo
	GETGLOB 13
	INDEX 7
	;; -
	PUSHINT 864000
	SUB
	UFITS 32
	GEQ
}
IF
; end function canProlongate

.macro isExpired
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
CALLREF {
	CALL $isExpired_internal_macro$
}
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHSLICE x000000000000000000000000340576152_
	STSLICER
	PUSH S1
	STIR 1
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	isExpired_internal
.type	isExpired_internal, @function
CALL $isExpired_internal_macro$

.macro isExpired_internal_macro
; function isExpired
;; return
;; push identifier now
NOW
;; >
;; get member dtExpires
;; push identifier _whoisInfo
GETGLOB 13
INDEX 7
GREATER
; end function isExpired

.macro callWhois
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function callWhois
CALLREF {
	CALL $_reserve_internal_macro$
}
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
PUSHINT 128
SETINDEXQ 4
SETGLOB 4
;; push identifier _whoisInfo
GETGLOB 13
; end function callWhois
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 1
	STUR 98
	NEWC
	STSLICECONST xf9bfc523
	PUSH S2
	PUSHINT 17
	UNTUPLEVAR
	PUSHINT 1
	PUSHINT 17
	BLKSWX
	PUSH S17
	STSLICER
	PUSH S16
	STUR 8
	PUSH S15
	STREFR
	PUSH S14
	STREFR
	PUSH S13
	STSLICER
	PUSH S12
	STSLICER
	PUSH S11
	STUR 32
	PUSH S10
	STUR 32
	NEWC
	PUSH S10
	STUR 128
	PUSH S9
	STUR 8
	PUSH S8
	STUR 8
	PUSH S7
	STREFR
	PUSH S6
	STUR 32
	PUSH S5
	STUR 128
	PUSH S4
	STUR 128
	PUSH S3
	STUR 128
	PUSH S2
	STUR 128
	PUSHINT 17
	PUSHINT 2
	BLKSWX
	PUSHINT 17
	DROPX
	STBREFR
	STBREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 1
	STUR 106
	NEWC
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S2
	PUSHINT 17
	UNTUPLEVAR
	PUSHINT 1
	PUSHINT 17
	BLKSWX
	PUSH S17
	STSLICER
	PUSH S16
	STUR 8
	PUSH S15
	STREFR
	PUSH S14
	STREFR
	PUSH S13
	STSLICER
	PUSH S12
	STSLICER
	PUSH S11
	STUR 32
	PUSH S10
	STUR 32
	NEWC
	PUSH S10
	STUR 128
	PUSH S9
	STUR 8
	PUSH S8
	STUR 8
	PUSH S7
	STREFR
	PUSH S6
	STUR 32
	PUSH S5
	STUR 128
	PUSH S4
	STUR 128
	PUSH S3
	STUR 128
	PUSH S2
	STUR 128
	PUSHINT 17
	PUSHINT 2
	BLKSWX
	PUSHINT 17
	DROPX
	STBREFR
	STBREFR
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getWhois
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; function getWhois
;; return
;; push identifier _whoisInfo
GETGLOB 13
; end function getWhois
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHINT 1
	STUR 98
	NEWC
	STSLICECONST x8adc14ca
	PUSH S2
	PUSHINT 17
	UNTUPLEVAR
	PUSHINT 1
	PUSHINT 17
	BLKSWX
	PUSH S17
	STSLICER
	PUSH S16
	STUR 8
	PUSH S15
	STREFR
	PUSH S14
	STREFR
	PUSH S13
	STSLICER
	PUSH S12
	STSLICER
	PUSH S11
	STUR 32
	PUSH S10
	STUR 32
	NEWC
	PUSH S10
	STUR 128
	PUSH S9
	STUR 8
	PUSH S8
	STUR 8
	PUSH S7
	STREFR
	PUSH S6
	STUR 32
	PUSH S5
	STUR 128
	PUSH S4
	STUR 128
	PUSH S3
	STUR 128
	PUSH S2
	STUR 128
	PUSHINT 17
	PUSHINT 2
	BLKSWX
	PUSHINT 17
	DROPX
	STBREFR
	STBREFR
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro callEndpointAddress
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
LDU 32
GETGLOB 4
ROT
SETINDEXQ 5
SETGLOB 4
; Decode input parameters
ENDS
; function callEndpointAddress
CALLREF {
	CALL $_reserve_internal_macro$
}
;; return
GETGLOB 4
PUSHINT 0
SETINDEXQ 2
PUSHINT 128
SETINDEXQ 4
SETGLOB 4
;; get member endpointAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 0
; end function callEndpointAddress
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHSLICE x0000000000000000000000003734896f6_
	STSLICER
	PUSH S1
	STSLICER
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
PUSHCONT {
	GETGLOB 4
	DUP
	INDEX 3
	PUSH S1
	INDEX 2
	GETGLOB 9
	BLKSWAP 1, 3
	INDEX 1
	NEWC
	PUSHINT 2
	STZEROES
	STI 1
	PUSHINT 3
	STZEROES
	STSLICE
	SWAP
	STGRAMS
	STDICT
	PUSHINT 106
	STZEROES
	GETGLOB 4
	INDEX 5
	STUR 32
	PUSH S1
	STSLICER
	ENDC
	GETGLOB 4
	INDEX 4
	SENDRAWMSG
}
IFELSE
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro getEndpointAddress
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; function getEndpointAddress
;; return
;; get member endpointAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 0
; end function getEndpointAddress
;; emitting 1 value(s)
PUSH S1
EQINT -1
PUSHCONT {
	PUSH S3
	CTOS
	LDU 2
	LDMSGADDR
	DROP
	NIP
	NEWC
	STSLICECONST xc
	STSLICE
	PUSHSLICE x00000000000000000000000022d07b072_
	STSLICER
	PUSH S1
	STSLICER
	ENDC
	PUSHINT 0
	SENDRAWMSG
}
IF
DROP
IFREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	_reserve_internal
.type	_reserve_internal, @function
CALL $_reserve_internal_macro$

.macro _reserve_internal_macro
; function _reserve
PUSHINT 500000
PUSHINT 0
CALLREF {
	CALL $__gasToTon_macro$
}
;; decl: balance
;; get member balance
GETPARAM 7
INDEX 0
;; >
;; push identifier balance
PUSH S1
GREATER
;; short-circuiting ||
DUP
PUSHCONT {
	DROP
	;; get member value
	CALLREF {
		CALL $message_balance_macro$
	}
	;; >
	;; push identifier balance
	PUSH S1
	GREATER
}
IFNOT
THROWIFNOT 211
;; push identifier balance
DUP
PUSHINT 0
RAWRESERVE
DROP
; end function _reserve

.macro changeEndpointAddress
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode newAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: newAddress
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function changeEndpointAddress
CALLREF {
	CALL $_reserve_internal_macro$
}
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
;; push identifier newAddress
PUSH S1
; colValue
SETINDEX 0
SETGLOB 13
; end colValue
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function changeEndpointAddress
; end modifier notExpired
; end modifier onlyOwner
DROP
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro changeRegistrationType
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode newType
LDU 8
ENDS
;; param: newType
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function changeRegistrationType
;; push identifier newType
DUP
;; <
;; get member NUM
LESSINT 4
THROWIFNOT 206
CALLREF {
	CALL $_reserve_internal_macro$
}
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
;; push identifier newType
PUSH S1
; colValue
SETINDEX 9
SETGLOB 13
; end colValue
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function changeRegistrationType
; end modifier notExpired
; end modifier onlyOwner
DROP
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro changeRegistrationPrice
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode newPrice
LDUQ 128
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDU 128
}
IFNOT
ENDS
;; param: newPrice
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function changeRegistrationPrice
CALLREF {
	CALL $_reserve_internal_macro$
}
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
;; push identifier newPrice
PUSH S1
; colValue
SETINDEX 8
SETGLOB 13
; end colValue
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function changeRegistrationPrice
; end modifier notExpired
; end modifier onlyOwner
DROP
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro changeComment
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode newComment
LDREF
ENDS
;; param: newComment
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function changeComment
CALLREF {
	CALL $_reserve_internal_macro$
}
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
;; push identifier newComment
PUSH S1
; colValue
SETINDEX 11
SETGLOB 13
; end colValue
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function changeComment
; end modifier notExpired
; end modifier onlyOwner
DROP
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	_changeOwner_internal
.type	_changeOwner_internal, @function
CALL $_changeOwner_internal_macro$

.macro _changeOwner_internal_macro
;; param: newOwnerAddress
; function _changeOwner
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
;; push identifier newOwnerAddress
PUSH S1
; colValue
SETINDEX 5
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
; colValue
SETINDEX 0
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
;; get member DENY
PUSHINT 3
; colValue
SETINDEX 9
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
PUSHINT 0
; colValue
SETINDEX 8
; end colValue
; expValue
;; fetch _whoisInfo
DUP
SETGLOB 13
; end expValue
PUSHREF {
	.blob x
}
; colValue
SETINDEX 11
SETGLOB 13
; end colValue
; end function _changeOwner
DROP

.macro changeOwner
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
; Decode newOwnerAddress
LDMSGADDRQ
PUSHREFCONT {
	;; load next cell
	LDREF
	ENDS
	CTOS
	LDMSGADDR
}
IFNOT
ENDS
;; param: newOwnerAddress
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function changeOwner
;; push identifier newOwnerAddress
DUP
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SDEQ
THROWIF 212
;; push identifier newOwnerAddress
DUP
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
SDEQ
THROWIF 213
CALLREF {
	CALL $_reserve_internal_macro$
}
;; emit ownerChanged
PUSHSLICE xc00000000000000000000000004e3e0d68
NEWC
STSLICE
;; dt
;; push identifier now
NOW
STUR 32
;; oldOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
STSLICER
;; newOwner
;; push identifier newOwnerAddress
PUSH S1
STSLICER
ENDC
PUSHINT 0
SENDRAWMSG
;; push identifier newOwnerAddress
DUP
CALLREF {
	CALL $_changeOwner_internal_macro$
}
PUSHINT 1
; expValue
;; fetch _whoisInfo
GETGLOB 13
DUP
INDEX 13
; end expValue
ROT
ADD
UFITS 128
; colValue
SETINDEX 13
SETGLOB 13
; end colValue
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function changeOwner
; end modifier notExpired
; end modifier onlyOwner
DROP
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro prolongate
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function prolongate
CALLREF {
	CALL $canProlongate_internal_macro$
}
THROWIFNOT 205
CALLREF {
	CALL $_reserve_internal_macro$
}
;; push identifier ninetyDays
;; *
PUSHINT 7776000
UFITS 32
; expValue
;; fetch _whoisInfo
GETGLOB 13
DUP
INDEX 7
; end expValue
ROT
ADD
UFITS 32
; colValue
SETINDEX 7
SETGLOB 13
; end colValue
;; emit domainProlongated
PUSHSLICE xc0000000000000000000000000537a68ab
NEWC
STSLICE
;; dt
;; push identifier now
NOW
STUR 32
;; expirationDate
;; get member dtExpires
;; push identifier _whoisInfo
GETGLOB 13
INDEX 7
STUR 32
ENDC
PUSHINT 0
SENDRAWMSG
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function prolongate
; end modifier notExpired
; end modifier onlyOwner
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.macro releaseDomain
DROP
GETGLOB 1
ISNULL
IFREF {
	CALL $c4_to_c7$
}
; Decode input parameters
ENDS
; modifier onlyOwner
;; get member ownerAddress
;; push identifier _whoisInfo
GETGLOB 13
INDEX 5
;; get member sender
GETGLOB 9
SDEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; get member sender
	GETGLOB 9
	;; push identifier addressZero
	;; address.makeAddrStd()
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	SDEQ
	NOT
}
IF
THROWIFNOT 100
; modifier notExpired
;; !
CALLREF {
	CALL $isExpired_internal_macro$
}
THROWIF 201
; function releaseDomain
CALLREF {
	CALL $_reserve_internal_macro$
}
;; push identifier addressZero
;; address.makeAddrStd()
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
CALLREF {
	CALL $_changeOwner_internal_macro$
}
; expValue
;; fetch _whoisInfo
GETGLOB 13
; end expValue
PUSHINT 0
; colValue
SETINDEX 7
SETGLOB 13
; end colValue
;; emit domainReleased
PUSHSLICE xc00000000000000000000000004ca6612b
NEWC
STSLICE
;; dt
;; push identifier now
NOW
STUR 32
ENDC
PUSHINT 0
SENDRAWMSG
;; transfer()
;; get member sender
GETGLOB 9
NEWC
STSLICECONST x42_
STSLICE
PUSHINT 111
STZEROES
ENDC
PUSHINT 128
SENDRAWMSG
; end function releaseDomain
; end modifier notExpired
; end modifier onlyOwner
CALLREF {
	CALL $c7_to_c4$
}
TRUE
SETGLOB 7

.globl	splitString_internal
.type	splitString_internal, @function
CALL $splitString_internal_macro$

.macro splitString_internal_macro
;; param: stringToSplit
; function splitString
;; push identifier stringToSplit
DUP
PUSHINT 4294967295
CDATASIZE
DROP
NIP
RSHIFT 3
;; >=
PUSHINT 2
GEQ
;; short-circuiting &&
DUP
PUSHCONT {
	DROP
	;; push identifier stringToSplit
	DUP
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	;; <=
	;; push identifier MAX_DOMAIN_LENGTH
	;; *
	PUSHINT 124
	UFITS 32
	;; +
	;; push identifier MAX_SEPARATORS_NUMBER
	PUSHINT 4
	;; -
	DEC
	UFITS 32
	ADD
	UFITS 32
	LEQ
}
IF
THROWIFNOT 200
;; push identifier stringToSplit
DUP
;; bytes
;; decl: stringToSplitBytes
PUSHINT 0
NEWDICT
PAIR
;; decl: finalWordsArray
PUSHINT 0
;; decl: lastPos
; for
PUSHINT 0
;; decl: i
PUSHCONT {
	;; push identifier i
	;; <
	;; get member length
	;; push identifier stringToSplitBytes
	PUSH2 S0, S3
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	LESS
}
PUSHCONT {
	;; index
	;; push identifier stringToSplitBytes
	PUSH S3
	CTOS
	;; push identifier i
	PUSH S1
	CALLREF {
		PUSHINT 127
		DIVMOD
		ROTREV
		PUSHCONT {
			PLDREF
			CTOS
		}
		REPEAT
		SWAP
		MULCONST 8
		SDSKIPFIRST
		PLDU 8
	}
	;; decl: letter
	;; if
	;; push identifier letter
	DUP
	;; ==
	EQINT 47
	PUSHCONT {
		;; if
		;; push identifier i
		;; -
		;; push identifier lastPos
		PUSH2 S1, S2
		SUB
		UFITS 256
		GTINT 0
		PUSHCONT {
			; expValue
			; end expValue
			;; push identifier stringToSplit
			PUSH2 S3, S5
			;; push identifier lastPos
			;; push identifier i
			BLKPUSH 2, 4
			;; -
			;; push identifier lastPos
			PUSH S6
			SUB
			UFITS 256
			CALLREF {
				CALL $__substr_macro$
			}
			;; array.push(..)
			SWAP
			UNPAIR
			PUSH S1
			INC
			XCHG s3
			ROTREV
			PUSHINT 32
			DICTUSETREF
			PAIR
			; colValue
			POP S4
			; end colValue
		}
		IF
		;; end if
		; expValue
		; end expValue
		;; push identifier i
		PUSH S1
		;; +
		INC
		; colValue
		POP S3
		; end colValue
	}
	IF
	;; end if
	DROP
	;; ++
	; expValue
	; end expValue
	INC
	; colValue
	; end colValue
}
WHILE
DROP
; end for
;; if
;; get member length
;; push identifier stringToSplitBytes
PUSH S2
PUSHINT 4294967295
CDATASIZE
DROP
NIP
RSHIFT 3
;; -
;; push identifier lastPos
PUSH S1
SUB
UFITS 256
GTINT 0
PUSHCONT {
	; expValue
	; end expValue
	;; push identifier stringToSplit
	;; push identifier lastPos
	PUSH3 S1, S3, S0
	;; get member length
	;; push identifier stringToSplitBytes
	PUSH S5
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	;; -
	;; push identifier lastPos
	PUSH S4
	SUB
	UFITS 256
	;; -
	DEC
	UFITS 256
	CALLREF {
		CALL $__substr_macro$
	}
	;; array.push(..)
	SWAP
	UNPAIR
	PUSH S1
	INC
	XCHG s3
	ROTREV
	PUSHINT 32
	DICTUSETREF
	PAIR
	; colValue
	POP S2
	; end colValue
}
IF
;; end if
;; return
;; push identifier finalWordsArray
PUSH S1
BLKDROP2 3, 1
; end function splitString
NIP

.globl	_validateDomainName_internal
.type	_validateDomainName_internal, @function
CALL $_validateDomainName_internal_macro$

.macro _validateDomainName_internal_macro
;; param: domainName
;; ret param: retParam@0
PUSHINT 0
; function _validateDomainName
PUSHCONT {
	;; if
	;; get member length
	;; push identifier domainName
	PUSH S1
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	LESSINT 2
	;; short-circuiting ||
	DUP
	PUSHCONT {
		DROP
		;; get member length
		;; push identifier domainName
		PUSH S1
		PUSHINT 4294967295
		CDATASIZE
		DROP
		NIP
		RSHIFT 3
		;; >
		;; push identifier MAX_DOMAIN_LENGTH
		;; *
		PUSHINT 124
		UFITS 32
		;; +
		;; push identifier MAX_SEPARATORS_NUMBER
		PUSHINT 4
		;; -
		DEC
		UFITS 32
		ADD
		UFITS 32
		GREATER
	}
	IFNOT
	PUSHCONT {
		;; return
		DROP
		FALSE
	}
	IFJMP
	;; end if
	;; decl: separatorCount
	;; decl: lastSeparatorPos
	; for
	PUSHINT 0
	BLKPUSH 2, 0
	;; decl: i
	FALSE ; decl return flag
	PUSHCONT {
		DUP
		LESSINT 2
		DUP
		PUSHCONT {
			DROP
			;; push identifier i
			;; <
			;; get member length
			;; push identifier domainName
			PUSH2 S1, S5
			PUSHINT 4294967295
			CDATASIZE
			DROP
			NIP
			RSHIFT 3
			LESS
		}
		IF
	}
	PUSHCONT {
		PUSHCONT {
			;; index
			;; push identifier domainName
			PUSH S5
			CTOS
			;; push identifier i
			PUSH S2
			CALLREF {
				PUSHINT 127
				DIVMOD
				ROTREV
				PUSHCONT {
					PLDREF
					CTOS
				}
				REPEAT
				SWAP
				MULCONST 8
				SDSKIPFIRST
				PLDU 8
			}
			;; decl: letter
			;; push identifier letter
			DUP
			;; >=
			PUSHINT 48
			GEQ
			;; short-circuiting &&
			DUP
			PUSHCONT {
				DROP
				;; push identifier letter
				DUP
				;; <=
				PUSHINT 57
				LEQ
			}
			IF
			;; decl: numbers
			;; push identifier letter
			PUSH S1
			;; >=
			PUSHINT 97
			GEQ
			;; short-circuiting &&
			DUP
			PUSHCONT {
				DROP
				;; push identifier letter
				PUSH S1
				;; <=
				PUSHINT 122
				LEQ
			}
			IF
			;; decl: lower
			;; push identifier letter
			PUSH S2
			;; ==
			EQINT 45
			;; decl: dash
			;; push identifier letter
			PUSH S3
			;; ==
			EQINT 47
			;; decl: slash
			;; if
			;; !
			;; push identifier numbers
			PUSH S3
			NOT
			;; short-circuiting &&
			DUP
			PUSHCONT {
				DROP
				;; !
				;; push identifier lower
				PUSH S2
				NOT
				;; short-circuiting &&
				DUP
				PUSHCONT {
					DROP
					;; !
					;; push identifier dash
					PUSH S1
					NOT
					;; short-circuiting &&
					DUP
					PUSHCONT {
						DROP
						;; !
						;; push identifier slash
						DUP
						NOT
					}
					IF
				}
				IF
			}
			IF
			PUSHCONT {
				;; return
				FALSE
				BLKDROP2 10, 1
				PUSHINT 4
			}
			IFJMP
			;; end if
			;; if
			FALSE ; decl return flag
			;; push identifier slash
			PUSH S1
			PUSHCONT {
				; expValue
				; end expValue
				PUSH S9
				INC
				UFITS 32
				; colValue
				POP S10
				; end colValue
				;; push identifier i
				;; -
				;; push identifier lastSeparatorPos
				PUSH2 S7, S8
				SUB
				UFITS 32
				;; decl: len
				;; push identifier lastSeparatorPos
				PUSH S9
				EQINT 0
				PUSHCONT {
					PUSHINT 0
				}
				PUSHCONT {
					PUSHINT 1
				}
				IFELSE
				;; decl: extraSlash
				;; if
				;; push identifier len
				PUSH S1
				EQINT 0
				;; short-circuiting ||
				DUP
				PUSHCONT {
					DROP
					;; !
					;; push identifier len
					;; -
					;; push identifier extraSlash
					DUP2
					SUB
					UFITS 32
					;; param: length
					; function _validateSegmentLength
					;; return
					;; push identifier length
					DUP
					;; >=
					PUSHINT 2
					GEQ
					;; short-circuiting &&
					DUP
					PUSHCONT {
						DROP
						;; push identifier length
						DUP
						;; <=
						PUSHINT 31
						LEQ
					}
					IF
					; end function _validateSegmentLength
					NIP
					NOT
				}
				IFNOT
				PUSHCONT {
					;; return
					FALSE
					BLKDROP2 13, 1
					PUSHINT 4
				}
				IFJMP
				;; end if
				; expValue
				; end expValue
				;; push identifier i
				; colValue
				; end colValue
				DROP2
				PUSH S7
				POP S9
			}
			IF
			DUP
			IFRET
			;; end if
			BLKDROP 6
		}
		CALLX
		DUP
		GTINT 1
		IFRET
		;; ++
		; expValue
		PUSH S1
		; end expValue
		INC
		UFITS 32
		; colValue
		POP S2
		; end colValue
	}
	WHILE
	EQINT 4
	IFRET
	DROP
	; end for
	;; push identifier lastSeparatorPos
	DUP
	EQINT 0
	PUSHCONT {
		PUSHINT 0
	}
	PUSHCONT {
		PUSHINT 1
	}
	IFELSE
	;; decl: extraSlash
	;; get member length
	;; push identifier domainName
	PUSH S4
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	;; uint32
	UFITS 32
	;; -
	;; push identifier lastSeparatorPos
	PUSH S2
	SUB
	UFITS 32
	;; -
	;; push identifier extraSlash
	PUSH S1
	SUB
	UFITS 32
	;; decl: len
	;; if
	;; !
	;; push identifier len
	;; param: length
	; function _validateSegmentLength
	;; return
	;; push identifier length
	BLKPUSH 2, 0
	;; >=
	PUSHINT 2
	GEQ
	;; short-circuiting &&
	DUP
	PUSHCONT {
		DROP
		;; push identifier length
		DUP
		;; <=
		PUSHINT 31
		LEQ
	}
	IF
	; end function _validateSegmentLength
	NIP
	PUSHCONT {
		;; return
		FALSE
		BLKDROP2 5, 1
	}
	IFNOTJMP
	;; end if
	;; if
	;; push identifier separatorCount
	PUSH S3
	;; >
	;; push identifier MAX_SEPARATORS_NUMBER
	PUSHINT 4
	;; -
	DEC
	UFITS 32
	GREATER
	PUSHCONT {
		;; return
		FALSE
		BLKDROP2 5, 1
	}
	IFJMP
	;; end if
	;; return
	TRUE
	BLKDROP2 5, 1
}
CALLX
; end function _validateDomainName
NIP

.globl	_parseDomainName_internal
.type	_parseDomainName_internal, @function
CALL $_parseDomainName_internal_macro$

.macro _parseDomainName_internal_macro
;; param: domainName
;; ret param: retParam@0
PUSHINT 0
NEWDICT
PAIR
;; ret param: retParam@1
PUSHREF {
}
; function _parseDomainName
PUSHCONT {
	;; push identifier domainName
	PUSH S2
	CALLREF {
		CALL $splitString_internal_macro$
	}
	;; decl: segments
	;; if
	;; get member length
	;; push identifier segments
	DUP
	INDEX 0
	PUSHCONT {
		;; return
		;; push identifier segments
		DUP
		PUSHREF {
			.blob x
		}
		BLKDROP2 2, 3
		ROT
		DROP
	}
	IFNOTJMP
	;; end if
	;; index
	;; get member length
	;; push identifier segments
	DUP
	INDEX 0
	;; -
	DEC
	UFITS 256
	;; push identifier segments
	PUSH S1
	INDEX 1
	PUSHINT 32
	DICTUGETREF
	THROWIFNOT 50
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	;; uint32
	UFITS 32
	;; decl: lastSegmentName
	;; push identifier domainName
	PUSH S4
	PUSHINT 4294967295
	CDATASIZE
	DROP
	NIP
	RSHIFT 3
	;; uint32
	UFITS 32
	;; -
	;; push identifier lastSegmentName
	PUSH S1
	SUB
	UFITS 32
	;; -
	DEC
	UFITS 32
	;; decl: parentLength
	;; get member length
	;; push identifier segments
	PUSH S2
	INDEX 0
	EQINT 1
	PUSHCONT {
		;; push identifier domainName
		PUSH S5
	}
	PUSHCONT {
		;; push identifier domainName
		PUSH S5
		PUSHINT 0
		;; push identifier parentLength
		PUSH S2
		;; -
		DEC
		UFITS 32
		CALLREF {
			CALL $__substr_macro$
		}
	}
	IFELSE
	;; decl: parentName
	;; return
	;; push identifier segments
	;; push identifier parentName
	PUSH2 S3, S0
	BLKDROP2 6, 2
}
CALLX
; end function _parseDomainName
BLKDROP2 1, 2

.macro c7_to_c4
GETGLOB 2
NEWC
STU 256
GETGLOB 3
STUR 64
GETGLOB 6
STUR 1
GETGLOB 10
GETGLOB 11
GETGLOB 12
GETGLOB 13
REVERSE 5, 0
STREF
STI 1
STREF
SWAP
CALLREF {
	PUSHINT 17
	UNTUPLEVAR
	NEWC
	NEWC
	PUSH S10
	STUR 128
	PUSH S9
	STUR 8
	PUSH S8
	STUR 8
	PUSH S7
	STREFR
	PUSH S6
	STUR 32
	PUSH S5
	STUR 128
	PUSH S4
	STUR 128
	PUSH S3
	STUR 128
	PUSH S2
	STUR 128
	STBREFR
	PUSH S17
	STSLICER
	PUSH S16
	STUR 8
	PUSH S15
	STREFR
	PUSH S14
	STREFR
	PUSH S13
	STSLICER
	PUSH S12
	STSLICER
	PUSH S11
	STUR 32
	PUSH S10
	STUR 32
	PUSHINT 17
	PUSHINT 1
	BLKSWX
	PUSHINT 17
	DROPX
}
STBREFR
ENDC
POP C4

.macro c4_to_c7
PUSHROOT
CTOS        ; c4
LDU 256      ; pubkey c4
LDU 64      ; pubkey timestamp c4
LDU 1       ; pubkey [timestamp] constructor_flag memory
LDREF
LDI 1
LDREF
LDREFRTOS
NIP
LDREF
LDMSGADDR
LDU 8
LDREF
LDREF
LDMSGADDR
LDMSGADDR
LDU 32
PLDU 32
BLKSWAP 1, 8
CTOS
LDU 128
LDU 8
LDU 8
LDREF
LDU 32
LDU 128
LDU 128
LDU 128
PLDU 128
PUSHINT 17
TUPLEVAR
SETGLOB 13
SETGLOB 12
SETGLOB 11
SETGLOB 10
TRUE
SETGLOB 1   ; pubkey [timestamp] constructor_flag
SETGLOB 6   ; pubkey [timestamp]
SETGLOB 3   ; D
SETGLOB 2

.macro c4_to_c7_with_init_storage
PUSHROOT
CTOS        ; c4
DUP        ; c4 c4
SBITS      ; c4 bits
GTINT 1    ; c4 bits>1
PUSHCONT {
	LDU 256      ; pubkey c4
	LDU 64      ; pubkey timestamp c4
	LDU 1       ; pubkey [timestamp] constructor_flag memory
	LDREF
	LDI 1
	LDREF
	LDREFRTOS
	NIP
	LDREF
	LDMSGADDR
	LDU 8
	LDREF
	LDREF
	LDMSGADDR
	LDMSGADDR
	LDU 32
	PLDU 32
	BLKSWAP 1, 8
	CTOS
	LDU 128
	LDU 8
	LDU 8
	LDREF
	LDU 32
	LDU 128
	LDU 128
	LDU 128
	PLDU 128
	PUSHINT 17
	TUPLEVAR
	SETGLOB 13
	SETGLOB 12
	SETGLOB 11
	SETGLOB 10
	TRUE
	SETGLOB 1   ; pubkey [timestamp] constructor_flag
	SETGLOB 6   ; pubkey [timestamp]
	SETGLOB 3   ; D
	SETGLOB 2
}
PUSHCONT {
	PLDDICT   ; D
	; init _domainName
	PUSHINT 1
	PUSH S1
	PUSHINT 64
	DICTUGETREF
	PUSHCONT {
		PUSHREF {
		}
	}
	IFNOT
	SETGLOB 10
	; init _nameIsValid
	PUSHINT 0
	SETGLOB 11
	; init _domainCode
	PUSHINT 2
	PUSH S1
	PUSHINT 64
	DICTUGETREF
	PUSHCONT {
		PUSHREF {
		}
	}
	IFNOT
	SETGLOB 12
	; init _whoisInfo
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	PUSHINT 0
	PUSHREF {
	}
	PUSHREF {
	}
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
	PUSHINT 0
	BLKPUSH 4, 0
	PUSHREF {
	}
	PUSHINT 0
	BLKPUSH 4, 0
	PUSHINT 17
	TUPLEVAR
	SETGLOB 13
	; set contract pubkey
	PUSHINT 0
	SWAP
	PUSHINT 64
	DICTUGET
	THROWIFNOT 61
	PLDU 256
	SETGLOB 2
	PUSHINT 0 ; timestamp
	SETGLOB 3
	PUSHINT 0 ; constructor_flag
	SETGLOB 6
	TRUE
	SETGLOB 1
}
IFELSE

.internal-alias :main_internal, 0
.internal :main_internal
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_internal
;; param: contract_balance
;; param: msg_balance
;; param: int_msg_info
;; param: msg_body_slice
;; param: transaction_type
PUSH S2
CTOS
LDU 4       ; bounced tail
LDMSGADDR   ; bounced src tail
DROP
SETGLOB 9
MODPOW2 1
; beg set default params for responsible func
GETGLOB 4
; bounce
TRUE
SETINDEXQ 1
; tons
PUSHINT 10000000
SETINDEXQ 2
; currency
NULL
SETINDEXQ 3
; flag
PUSHINT 0
SETINDEXQ 4
SETGLOB 4
; end set default params for responsible func
IFRET
PUSH S1    ; body
SEMPTY     ; isEmpty
IFRET
PUSH S1 ; body
LDUQ 32  ; [funcId] body' ok
THROWIFNOT 60 ; funcId body'
PUSH S1 ; funcId body' funcId
IFNOTRET
SWAP
CALLREF {
	CALL $public_function_selector$
}
GETGLOB 7
ISNULL
THROWIF 60

.internal-alias :main_external, -1
.internal :main_external
PUSHSLICE x8000000000000000000000000000000000000000000000000000000000000000001_
SETGLOB 9
PUSH S1
CALLREF {
	CALL $c4_to_c7_with_init_storage$
}
LDU 1 ; haveSign msgSlice
SWAP
PUSHCONT {
	PUSHINT 512
	LDSLICEX ; signatureSlice msgSlice
	DUP      ; signatureSlice msgSlice msgSlice
	HASHSU   ; signatureSlice msgSlice hashMsgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice
	LDU 1 ; signatureSlice hashMsgSlice havePubkey msgSlice
	SWAP  ; signatureSlice hashMsgSlice msgSlice havePubkey
	PUSHCONT {
		LDU 256       ; signatureSlice hashMsgSlice pubkey msgSlice
		XCHG s3
		SWAP
	}
	PUSHCONT {
		XCHG s2
		GETGLOB 2
	}
	IFELSE
	DUP
	SETGLOB 5
	CHKSIGNU      ; msgSlice isSigned
	THROWIFNOT 40 ; msgSlice
}
PUSHCONT {
	LDU 1      ; havePubkey msgSlice
	SWAP       ; msgSlice havePubkey
	THROWIF 58 ; msgSlice
}
IFELSE
LDU 64                         ; timestamp msgSlice
SWAP                           ; msgSlice timestamp
CALL $replay_protection_macro$ ; msgSlice
LDU 32  ; expireAt msgSlice
SWAP    ; msgSlice expireAt
NOW     ; msgSlice expireAt now
GREATER ; msgSlice expireAt>now
THROWIFNOT 57
LDU  32 ; funcId body
SWAP    ; body funcId
CALLREF {
	CALL $public_function_selector$
}
GETGLOB 7
ISNULL
THROWIF 60

.macro public_function_selector
DUP
PUSHINT 188869660
LEQ
PUSHCONT {
	DUP
	PUSHINT 44944283
	LEQ
	PUSHCONT {
		DUP
		PUSHINT 31504196
		EQUAL
		IFJMPREF {
			CALL $callbackOnRegistrationRequest$
		}
		DUP
		PUSHINT 44944283
		EQUAL
		IFJMPREF {
			CALL $changeRegistrationPrice$
		}
	}
	IFJMP
	DUP
	PUSHINT 182195402
	LEQ
	PUSHCONT {
		DUP
		PUSHINT 71073226
		EQUAL
		IFJMPREF {
			CALL $getDomainCode$
		}
		DUP
		PUSHINT 182195402
		EQUAL
		IFJMPREF {
			CALL $getWhois$
		}
	}
	IFJMP
	DUP
	PUSHINT 188869660
	EQUAL
	IFJMPREF {
		CALL $getEndpointAddress$
	}
}
IFJMP
DUP
PUSHINT 842311097
LEQ
PUSHCONT {
	DUP
	PUSHINT 561722120
	LEQ
	PUSHCONT {
		DUP
		PUSHINT 421493331
		EQUAL
		IFJMPREF {
			CALL $claimExpired$
		}
		DUP
		PUSHINT 561722120
		EQUAL
		IFJMPREF {
			CALL $changeOwner$
		}
	}
	IFJMP
	DUP
	PUSHINT 765739228
	LEQ
	PUSHCONT {
		DUP
		PUSHINT 578346315
		EQUAL
		IFJMPREF {
			CALL $prolongate$
		}
		DUP
		PUSHINT 765739228
		EQUAL
		IFJMPREF {
			CALL $releaseDomain$
		}
	}
	IFJMP
	DUP
	PUSHINT 842311097
	EQUAL
	IFJMPREF {
		CALL $receiveRegistrationRequest$
	}
}
IFJMP
DUP
PUSHINT 1803205712
LEQ
PUSHCONT {
	DUP
	PUSHINT 1269959525
	LEQ
	PUSHCONT {
		DUP
		PUSHINT 1151146610
		EQUAL
		IFJMPREF {
			CALL $canProlongate$
		}
		DUP
		PUSHINT 1269959525
		EQUAL
		IFJMPREF {
			CALL $changeRegistrationType$
		}
	}
	IFJMP
	DUP
	PUSHINT 1557276093
	LEQ
	PUSHCONT {
		DUP
		PUSHINT 1343608916
		EQUAL
		IFJMPREF {
			CALL $isExpired$
		}
		DUP
		PUSHINT 1557276093
		EQUAL
		IFJMPREF {
			CALL $callEndpointAddress$
		}
	}
	IFJMP
	DUP
	PUSHINT 1803205712
	EQUAL
	IFJMPREF {
		CALL $changeEndpointAddress$
	}
}
IFJMP
DUP
PUSHINT 2049743627
LEQ
PUSHCONT {
	DUP
	PUSHINT 1832334119
	EQUAL
	IFJMPREF {
		CALL $calculateDomainAddress$
	}
	DUP
	PUSHINT 1842403657
	EQUAL
	IFJMPREF {
		CALL $changeComment$
	}
	DUP
	PUSHINT 2042610979
	EQUAL
	IFJMPREF {
		CALL $callWhois$
	}
	DUP
	PUSHINT 2049743627
	EQUAL
	IFJMPREF {
		CALL $constructor$
	}
}
IFJMP
